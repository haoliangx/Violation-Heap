#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "violation-heap.h"

#define SWAP_NODE(a, b) 	\
do {				\
	node_t *_temp = a;	\
	a = b;			\
	b = _temp;		\
}while(0)

/*

typedef struct _node
{
	key_t key;
	int rank;
	struct _node *next;
	struct _node *prev;
	struct _node *child;
}node_t;

typedef struct _v_heap
{
	int size;
	struct _node *root_list;
}heap_t;

*/

/*
void decrease_key(heap_t *heap, node_t *node, key_t new_key)
{

}

heap_t *meld(heap_t *heap_a, heap_t *heap_b)
{

}

node_t *find_min(heap_t *heap)
{

}

*/

void print_heap(heap_t *heap)
{
	return;
	printf("Heap size = %d\n", heap->size);
	node_t *node = heap->root_list;
	if(!node)
		printf("Heap has no child\n");
	else
	{
		printf("Heap Child: ");
		for(; node!=NULL; node = node->next)
		{
			printf("%d", node->key);
			if(node->child)
				printf("(C)");
			printf(" ");
		}
		printf("\n");
	}
}

/* Make a heap and return its pointer */
heap_t *make_heap()
{
	heap_t *heap = NULL;

	/* Allocate memory space for a new heap and initial it to all zero.
		Exit if calloc failed. */
	assert((heap = (heap_t *)calloc(1, sizeof(heap_t))) != NULL);

	return heap;
}

/* Make a node with the given key and return its pointer */
node_t *make_node(key_t key)
{
	node_t *node = NULL;

	/* Allocate memory space for a new node and initial it to all zero.
		Exit if calloc failed. */
	assert((node = (node_t *)calloc(1, sizeof(node_t))) != NULL);

	/* Assign key to the new node */
	node->key = key;

	return node;
}

/* Combine list_b into list_a */
void join_list(node_t **list_a, node_t **list_b)
{
	node_t *next, *curr;
	
	/* Handle corner cases */
	if(*list_b == NULL)
		return;
	if(*list_a == NULL)
	{
		*list_a = *list_b;
		return;
	}

	/* Let the list with greater key to be the primary list */
	if((*list_a)->key > (*list_b)->key)
		SWAP_NODE(*list_a, *list_b);

	/* Clear the the child pointer of list_b's parent (if any)*/
	if((*list_b)->prev)
		(*list_b)->prev->child = NULL;

	/* Save the break point of the primary list */
	next = (*list_a)->next;
	
	/* Connect one end of list_b */
	(*list_a)->next = *list_b;
	(*list_b)->prev = *list_a;

	/* Move curr to the other end of list_b */
	curr = *list_b;
	while(curr->next)
		curr = curr->next;

	/* Connect the other end */
	if(next)
	{
		curr->next = next;
		next->prev = curr;
	}
}

/* Insert a new key into the heap */
void *insert(heap_t *heap, key_t key)
{
	/* Make a new node */
	node_t *node = make_node(key);
	
	/* Insert the node */
	join_list(&heap->root_list, &node);
	
	/* Increase the heap size */
	heap->size++;
}

/* Link z1 to the child list of z */
void link(node_t *z, node_t *z1)
{
	node_t *child = z->child;
	
	/* Attach z1 to the last position in z's children list */
	z->child = z1;

	/* Pointer to its parent */
	z1->prev = z;

	/* Attach other children (if any) to the end of z1*/
	z1->next = child;
	if(child)
		child->prev = z1;
}

void consolidate(heap_t *heap)
{
	int i = 0;

	/* Allocate memory space to record nodes with the same rank */
	node_t **A_list = (node_t **)calloc(2 * heap->size, sizeof(node_t *));

	/* Temporary list to store all the nodes in the heap */
	node_t **root_list = (node_t **)calloc(heap->size, sizeof(node_t *));

	/* Put all roots in the temporary list */
	node_t *curr = heap->root_list;
	if(curr == NULL)
		return;
	while(curr)
	{
		root_list[i++] = curr;
		curr = curr->next;
	}

	/* Iterate through the temporary list */
	while(i-- > 0)
	{
		/* Unlink the current node z */
		node_t *z = root_list[i];
		z->prev = NULL;
		z->next = NULL;

		/* If there are two nodes with the same rank
			perform 3-way-join(z, z1, z2) */
		node_t *z1 = A_list[2 * z->rank];
		node_t *z2 = A_list[2 * z->rank + 1];
		while(z1 != NULL && z2 != NULL)
		{
			/* Sort z, z1, z2 */
			if(z->key > z1->key)
				SWAP_NODE(z, z1);
			if(z->key > z2->key)
				SWAP_NODE(z, z2);
			if(z1->key > z2->key)
				SWAP_NODE(z1, z2);

			/* Link z1 and z2 to z */
			link(z, z1);
			link(z, z2);
			
			/* Clear old position */
			A_list[2 * z->rank] = NULL;
			A_list[2 * z->rank + 1] = NULL;

			/* Increment rank */
			z->rank++;

			/* Update new z1 & z2 */
			z1 = A_list[2 * z->rank];
			z2 = A_list[2 * z->rank + 1];
		}

		/* Find a free space and put z back into the list */
		if(z1 == NULL)
			A_list[2 * z->rank] = z;
		else if(z2 == NULL)
			A_list[2 * z->rank + 1] = z;
	}

	/* Rebuild the root list from A_list */
	heap->root_list = NULL;
	for(i = 0; i < 2 * heap->size; i+=2)
	{
		node_t *p1 = A_list[i];
		node_t *p2 = A_list[i + 1];
		/*
		if(p1)
		{
			if(heap->root_list)
				join_list(&heap->root_list, &p1);
			else
				heap->root_list = p1;
			if(p2)
				join_list(&heap->root_list, &p2);
		}
		*/
		join_list(&heap->root_list, &p1);
		join_list(&heap->root_list, &p2);
	}
	
	/* Free the temporary lists */
	free(A_list);
	free(root_list);
}

node_t *extract_min(heap_t *heap)
{
	node_t *min_node = heap->root_list;
	print_heap(heap);
	if(min_node)
	{
		heap->root_list = min_node->next;
		heap->size--;
		node_t *child = min_node->child;
		if(child)
			join_list(&heap->root_list, &child);
		consolidate(heap);
	}
	print_heap(heap);
	return min_node;
}

#include <time.h>

int main()
{
	heap_t *heap = make_heap();
	int i;
	srand(time(0));
	printf("Insert: \n");
	for(i = 0; i < 20; i++)
	{
		int n = rand()%2000;
		insert(heap, n);
		printf("%d, ", n);
		fflush(stdout);
	}
	printf("\nExtract\n");
	for(i = 0; i < 20; i++)
	{
		node_t *min = extract_min(heap);
		if(min)
			printf("%d, ", min->key);
		else
			printf("NULL, ");
	}
	printf("\n");
}

